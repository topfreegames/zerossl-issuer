# ZeroSSL Issuer Project Rules

## Project Structure
- Follow Kubebuilder project layout conventions
- Keep core logic in internal/ directory
- Use api/v1alpha1/ for API definitions
- Place tests alongside the code they test
- Use config/ for all Kubernetes manifests
- Store e2e tests in test/e2e/

## Development Patterns

### API Design
- Follow cert-manager external issuer API conventions
- Use v1alpha1 for initial API version
- Include comprehensive CRD validation
- Document all API fields with kubebuilder markers
- Keep Issuer spec focused on ZeroSSL-specific fields

### Controller Implementation
- Use controller-runtime best practices
- Implement proper error handling and retries
- Follow cert-manager's reconciliation patterns
- Use conditions to report status
- Generate events for significant state changes

### Testing Requirements
- Write unit tests for all packages
- Include integration tests for controllers
- Implement e2e tests using Kind clusters
- Test with cert-manager installed
- Use Ginkgo/Gomega for testing

### Security Practices
- Run containers as non-root
- Use distroless base images
- Implement proper RBAC
- Keep secrets in same namespace as Issuer
- Follow Pod Security Standards

### Code Style
- Follow Go best practices
- Use golangci-lint for code quality
- Keep functions focused and small
- Document public APIs
- Use meaningful variable names

## Build and Deployment

### Make Targets
- Use make for build automation
- Include common targets:
  - build
  - test
  - docker-build
  - deploy
  - generate
  - manifests

### Container Images
- Build multi-arch images
- Use minimal base images
- Include version tags
- Set resource limits
- Configure security context

### Resource Management
- Use Kustomize for deployment
- Keep base resources separate
- Include namespace configuration
- Configure RBAC properly
- Set resource requests/limits

## Error Handling

### Controller Errors
- Differentiate between temporary and permanent errors
- Use proper error wrapping
- Include context in error messages
- Set appropriate conditions
- Generate relevant events

### API Client Errors
- Handle ZeroSSL API errors gracefully
- Implement proper retries
- Use exponential backoff
- Log meaningful error messages
- Update status conditions

## Monitoring and Observability

### Metrics
- Expose Prometheus metrics
- Include controller-specific metrics
- Monitor reconciliation success/failure
- Track API call latencies
- Measure certificate operations

### Logging
- Use structured logging
- Include request IDs
- Log at appropriate levels
- Include relevant context
- Follow logging best practices

## Documentation

### Code Documentation
- Document all exported types
- Include examples in godoc
- Explain complex logic
- Document assumptions
- Keep comments up to date

### User Documentation
- Provide clear installation instructions
- Include configuration examples
- Document troubleshooting steps
- Explain error conditions
- Keep README current

## Version Control

### Commit Messages
- Write descriptive commit messages
- Reference issues/PRs
- Keep commits focused
- Follow conventional commits
- Include context when needed

### Branch Management
- Use feature branches
- Keep main branch stable
- Tag releases properly
- Follow semver
- Document breaking changes

## Dependencies

### Go Dependencies
- Use go modules
- Pin dependency versions
- Regularly update dependencies
- Audit security vulnerabilities
- Document version constraints

### Kubernetes Dependencies
- Support multiple K8s versions
- Test against supported versions
- Use appropriate API versions
- Follow deprecation policies
- Document compatibility 